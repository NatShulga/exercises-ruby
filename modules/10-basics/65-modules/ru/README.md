
Одна из главных концепций в любом языке – разбиение кода на независимые модули с локальным именованием. В разных языках это делается разными словами, но похожими механизмами, такими как неймспейсы, пакеты, модули.

В Ruby для этого используется система модулей. Функции, определенные внутри модуля, локальны относительно этого модуля. То есть разные модули могут иметь внутри функции с одинаковыми именами.

```ruby
# file: module_name.rb
module MyModule
  def self.run
    'go!'
  end
end
```

При определении функции внутри модуля, к ней нужно добавлять префикс `self.`, только в этом случае получится её вызвать напрямую из модуля. Без `self.` функции тоже объявляют, но только тогда, когда модуль играет роль миксина. Это очень интересная концепция, которая всё чаще встречается в других языках. Подробнее о ней в соответствующем разделе.

```ruby
MyModule.run # 'go!'
```

Вызов функции из модуля выглядит абсолютно идентично вызову методов из класса. Является ли модуль классом? Это легко проверить:

```ruby
MyModule.new # undefined method `new' for MyModule:Module
# При этом модуль это объект
MyModule.class # Module
```

Как понять что перед нами класс, а не модуль? Короткий ответ: никак. Обычно это не проблема, потому что из контекста понятно, с чем идёт работа. В Ruby-мире много соглашений по тому, как работают библиотеки и как организуется код. Благодаря этому резко упрощается понимание происходящего.

Встроенных в Ruby модулей не так много. Из наиболее простого можно назвать Math, в котором лежат разные полезные математические функции:

```ruby
# Можно обращаться напрямую,
# встроенные модули всегда загружены
Math.sin(1)
```

Из наиболее используемых — модуль Kernel. С его помощью управляют поведением процесса и интерпретатора.

```ruby
Kernel.exit
```

Особенность этого модуля в том, что все функции модуля Kernel доступны для вызова напрямую, без указания имени модуля. Это происходит за счёт того, что модуль Kernel "подмешан" в класс Object, от которого наследуются практически все классы в Руби (неявно).

Если смотреть дальше, то возникает множество вопросов и разных интересных ситуаций: вложенные модули, модули вложенные в классы, классы вложенные в модули и даже классы вложенные в классы. Все это возможно в Ruby. А как соотносятся файловая система и модули? А можно ли определять классы без модулей? А можно ли вызывать функции модуля из функций модуля? К сожалению, не представляется возможным разобрать все эти вопросы в рамках нашего материала. За дальнейшими подробностями добро пожаловать на Хекслет!
