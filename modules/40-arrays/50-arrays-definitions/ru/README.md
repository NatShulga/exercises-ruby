
В Ruby необычно много способов создания массивов. Они помогают сделать определение короче, и достаточно часто используются на практике. Особенно любит их линтер Rubocop.

```ruby
# Обычное определение
['apple', 'orange', 'melon']

# Сокращенное
%w[apple orange melon]
```

`%w` позволяет задавать массив перечислением без использования дополнительных символов. Даже в примере выше видно, насколько код получается короче и даже читаемее. Единственное ограничение такого способа – наличие пробелов в значениях. Каждый пробел считается разделителем значений:

```ruby
%w[first second value third]
# ["first", "second", "value", "third"]
```

Технически, слова можно экранировать, но так обычно не делают из-за резкого ухудшения читаемости:

```ruby
%w[first second\ value third]
# ["first", "second value", "third"]
```

Похожим способом создается массив символов, только вместо `%w` используется `%i`:

```ruby
%i[apple orange melon] # [:apple, :orange, :melon]
```

Так же массивы можно создавать из диапазонов или итераторов:

```ruby
(1..5).to_a # [1, 2, 3, 4, 5]
1.upto(5).to_a # [1, 2, 3, 4, 5]
```

В некоторых достаточно редких случаях можно воспользоваться динамическим созданием значений. Для этого используется конструктор Array и блок, вычисляющий значение для нужного индекса:

```ruby
Array.new(5) { |i| i ** 2 }
# [0, 1, 4, 9, 16]
```
