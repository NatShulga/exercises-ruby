
Помимо обычных методов, массивы содержат большое число методов, работающих с блоками. Возьмем для примера метод `sort()`. Он умеет сортировать только на основе сравнения значений. Такая сортировка сработает в случае простых массивов из чисел, но окажется бесполезной в большинстве реальных ситуаций, где процесс сортировки может быть хитрым. Пример:

```ruby
# Население стран
data = [
  ['france', 140_000],
  ['usa', 300_000],
  ['germany', 40_000]
]
```

Как отсортировать страны по количеству жителей в них? Для таких ситуаций и нужны функции высшего порядка:

```ruby
# Внутрь передается блок,
# который принимает на вход элемент массива
data.sort_by { |row| row[1] }
# [
#   ['germany', 40_000],
#   ['france', 140_000],
#   ['usa', 300_000]
# ]

# Либо, если кода много
data.sort_by do |row|
  row[1]
end
```

Метод `sort_by()` ожидает, что из блока вернётся значение, по которому нужно выполнить сортировку. Затем, когда значения собраны, этот метод выполняет сортировку, сравнивая значения с помощью оператора `<=>`.

Вот некоторые примеры подобных функций:

* [max_by()](https://ruby-doc.org/core-3.0.0/Enumerable.html#method-i-max_by) – поиск максимального по указанному параметру в массиве
* [partition()](https://ruby-doc.org/core-3.0.0/Enumerable.html#method-i-partition) – разделяет массив на два по указанному условию

Таких функций у массивов десятки. Единственный способ их запомнить – постоянно практиковаться и читать документацию.
